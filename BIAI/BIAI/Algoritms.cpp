#include "Algoritms.h"

Algoritms::Algoritms(int r, int c, int dN){
	this->row = r;
	this->column = c;
	this->decksNumber = dN;
}

//r <0-9>, c <0-35> -> i == r, j == c

int Algoritms::strategicCard() {		//tab[0][0] => r 20, c2
	int strategicTable[35][10] = { {2,2,2,2,2,2,2,2,2,2},{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,1,1,1,1,1 },{ 2,2,2,2,2,1,1,1,1,1 },{ 2,2,2,2,2,1,1,1,1,1 },{ 2,2,2,2,2,1,1,1,1,1 },{ 1,1,2,2,2,1,1,1,1,1 },{3,3,3,3,3,3,3,3,3,1},
	{ 3,3,3,3,3,3,3,3,1,1 }, {1,3,3,3,1,1,1,1,1,1}, {1,1,1,1,1,1,1,1,1,1},{ 1,1,1,1,1,1,1,1,1,1 },{ 1,1,1,1,1,1,1,1,1,1 },{ 1,1,1,1,1,1,1,1,1,1 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{2,3,3,3,3,2,2,1,1,1},{1,3,3,3,3,1,1,1,1,1},{1,1,3,3,3,1,1,1,1,1},
	{ 1,1,3,3,3,1,1,1,1,1 },{ 1,1,1,3,3,1,1,1,1,1 },{ 1,1,1,3,3,1,1,1,1,1 },{4,4,4,4,4,4,4,4,4,4}, {2,2,2,2,2,2,2,2,2,2},{4,4,4,4,4,2,4,4,2,2},{ 4,4,4,4,4,4,4,4,4,4 },{4,4,4,4,4,4,1,1,1,1},{4,4,4,4,4,1,1,1,1,1},{3,3,3,3,3,3,3,3,1,1},{1,1,1,4,4,1,1,1,1,1},{4,4,4,4,4,4,1,1,1,1},{ 4,4,4,4,4,4,1,1,1,1} };
	
	return strategicTable[this->column][this->row];
}

int Algoritms::countingCards() {		//tab[0][0] => r 20, c2
	int strategicTable[35][10] = { { 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,1,1,1,1,1 },{ 2,2,2,2,2,1,1,1,1,1 },{ 2,2,2,2,2,1,1,1,1,1 },{ 2,2,2,2,2,1,1,1,1,1 },{ 1,1,2,2,2,1,1,1,1,1 },{ 3,3,3,3,3,3,3,3,3,1 },
	{ 3,3,3,3,3,3,3,3,1,1 },{ 1,3,3,3,3,1,1,1,1,1 },{ 1,1,1,1,1,1,1,1,1,1 },{ 1,1,1,1,1,1,1,1,1,1 },{ 1,1,1,1,1,1,1,1,1,1 },{ 1,1,1,1,1,1,1,1,1,1 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,3,3,3,3,2,2,1,1,1 },{ 1,3,3,3,3,1,1,1,1,1 },{ 1,1,3,3,3,1,1,1,1,1 },
	{ 1,1,3,3,3,1,1,1,1,1 },{ 1,1,1,3,3,1,1,1,1,1 },{ 1,1,1,3,3,1,1,1,1,1 },{ 4,4,4,4,4,4,4,4,4,4 },{ 2,2,2,2,2,2,2,2,2,2 },{ 4,4,4,4,4,2,4,4,2,2 },{ 4,4,4,4,4,4,4,4,4,4 },{ 4,4,4,4,4,4,1,1,1,1 },{ 4,4,4,4,4,1,1,1,1,1 },{ 3,3,3,3,3,3,3,3,1,1 },{ 1,1,1,4,4,1,1,1,1,1 },{ 4,4,4,4,4,4,1,1,1,1 },{ 4,4,4,4,4,4,1,1,1,1 } };
	
	int changedTable[35][10] = { { 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,2,2,1,1,3,3,1 },{ 2,2,2,2,2,1,1,1,3,1 },{ 1,1,2,2,2,1,1,1,1,1 },{ 1,1,1,1,1,1,1,1,1,1 },{ 3,3,1,1,1,1,1,1,1,1 },{ 3,3,3,3,3,3,3,1,1,3 },
	{ 3,3,3,3,3,3,1,1,3,3 },{ 3,1,1,1,3,3,1,1,1,1 },{ 1,1,3,3,3,1,1,1,1,1 },{ 1,1,3,3,3,1,1,1,1,1 },{ 1,1,3,3,3,1,1,1,1,1 },{ 1,1,3,3,3,1,1,1,1,1 },{ 2,2,2,2,2,2,2,2,2,2 },{ 2,2,2,3,3,2,2,2,2,2 },{ 2,3,3,3,3,2,2,2,2,2 },{ 3,1,3,3,3,2,2,1,1,1 },{ 3,1,3,3,3,1,1,1,1,1 },{ 1,3,1,3,3,1,1,1,1,1 },
	{ 1,1,1,1,3,1,1,1,1,1 },{ 1,1,3,1,1,1,1,1,1,1 },{ 1,1,3,1,1,1,1,1,1,1 },{ 4,4,4,4,4,4,4,4,4,1 },{ 2,2,3,3,3,2,2,2,2,2 },{ 1,1,1,4,4,2,4,4,2,2 },{ 4,4,4,4,4,4,4,4,4,4 },{ 4,4,4,4,4,4,3,1,1,1 },{ 1,1,1,4,4,1,1,1,1,1 },{ 3,3,3,3,3,3,1,1,3,3 },{ 1,1,3,1,1,1,1,1,1,1 },{ 1,1,4,4,4,4,3,1,1,1 },{ 1,4,4,4,4,4,1,1,1,1 } };

	int valueTable[35][10] = { {8,8,8,8,8,8,8,8,8,8},{ 8,8,8,8,8,8,8,8,8,8 } ,{ 8,8,8,8,8,8,8,8,8,8 } ,{ 8,8,8,8,8,8,8,8,8,8 }, {8,8,8,8,8,8,8,5,0,8}, {8,8,8,8,8,8,8,8,4,8}, {-4,-5,8,8,8,8,8,8,8,8}, {-1,-2,-4,-5,-5,8,8,8,8,8},{3,2,-10,-2,-1,8,8,8,8,8}, {8,8,8,8,8,8,8,-5,-5,1}, 
	{8,8,8,8,8,8,-5,-2,4,4},{1,-1,-3,5,8,3,8,8,8,8}, {8,8,5,3,1,8,8,8,8,8},{ 8,8,5,3,1,8,8,8,8,8 },{ 8,8,5,3,1,8,8,8,8,8 },{ 8,8,5,3,1,8,8,8,8,8 },{8,8,8,8,8,8,8,8,8,8},{8,8,8,5,4,8,8,8,8,8},{8,5,3,1,1,8,8,8,8,8}, {0,-3,8,8,8,8,8,8,8,8}, {1,-4,8,8,8,8,8,8,8,8}, {8,4,-3,8,8,8,8,8,8,8}, 
	{8,8,-1,-5,8,8,8,8,8,8}, {8,8,1,-2,-5,8,8,8,8,8}, {8,8,3,-10,-2,8,8,8,8,8}, {8,8,8,8,8,8,8,8,8,-4}, {8,8,6,5,4,8,8,8,8,8},{-3,-4,-6,8,8,8,8,8,8,8}, {8,8,8,8,8,8,8,8,8,8}, {8,8,8,8,8,8,5,8,8,8}, {-2,-2,-5,8,8,8,8,8,8,8}, {8,8,8,8,8,8,-5,-2,4,1}, {8,8,1,-2,-5,8,8,8,8,8}, {-10,-5,8,8,8,8,4,8,8,8}, {-4,8,8,8,8,8,8,8,8,8} };

	
	//wyznaczanie wartoœci prawdziwej! Trzeba zrobiæ jak bêd¹ karty
	int trueValue = 0;
	trueValue = countTrueValue();

	if (valueTable[this->column][this->row] == 8) {
		return strategicTable[this->column][this->row];
	}
	else if (valueTable[this->column][this->row] == -10) {
		if (trueValue <= 0) {
			return changedTable[this->column][this->row];
		}
		else {
			return strategicTable[this->column][this->row];
		}
	}
	else if (valueTable[this->column][this->row] < 0) {
		if (trueValue <= valueTable[this->column][this->row]) {
			return changedTable[this->column][this->row];
		}
		else {
			return strategicTable[this->column][this->row];
		}
	}
	else {
		if (trueValue >= valueTable[this->column][this->row]) {
			return changedTable[this->column][this->row];
		}
		else {
			return strategicTable[this->column][this->row];
		}
	}

	/*
	h+x -> D
	d-x -> H
	st-x -> H
	st+x -> D
	sp-x -> H
	-0 =^= -10
	*/
	
}

int Algoritms::countTrueValue() {		//trzeba dokoñczyæ!
	return 0;
}

int Algoritms::sameBid(int lastBid) {
	return lastBid;
}

int Algoritms::paroliBid(int firstBid, int lastBid, bool victory) {
	if (victory) {
		return lastBid + (0.2*firstBid);
	}
	else {
		if (lastBid - (0.2*firstBid) <= firstBid) {
			return firstBid;
		}
		else {
			return lastBid - (0.2*firstBid);
		}
	}
}

int Algoritms::countingBid(int firstBid) {
	int trueValue = countTrueValue();
	if (trueValue <= 1) {
		return firstBid;
	}
	else {
		switch (trueValue){
		case 2:
			return firstBid*1.5;
			break;
		case 3: 
			return firstBid * 2;
			break;
		case 4:
			return firstBid*2.5;
			break;
		case 5:
			return firstBid*3;
			break;
		default:
			return firstBid;
			break;
		}
	}
}

int Algoritms::OscarGrrindBid(int firstBid, int lastBid, bool victory, int profit) {
	if (victory) {
		if (profit >= 0) {
			return firstBid;
		}
		else {			
			if (profit+lastBid > firstBid) {
				return firstBid - profit;
			}
			else {
				return lastBid + firstBid;
			}
		}
	}
	else {
		return lastBid;
	}
}